/*
* ============================================================================
*  Name     : CSecureAppUi from SecureAppUi.cpp
*  Part of  : Secure
*  Created  : 8/6/2005 by Ezhil
*  Implementation notes:
*     Initial content was generated by Series 60 AppWizard.
*  Version  :
*  Copyright: Purpleace
* ============================================================================
*/

// INCLUDE FILES
#include "SecureAppUi.h"

#include "SmsLockEngine.h"
#include "SmsUnLockEngine.h"
#include "SoundEngine.h"
#include "SmsVacuumEngine.h"
#include "smsfile.h"
#include "PassWordEngine.h"
#include "ScreenUpdateEngine.h"
#include "SmsUnSubscribeEngine.h"

#ifdef __UIQ__	

#ifdef __S80__
	#include <secure_s80.rsg>
	#include "Secure_s80.hrh"	
	#include <eikenv.h> 
	#include <eikbtgpc.h> 
	#include "imsi.h"

	#include "SecureAppView.h"
#else
	#include <etelagsm.h>
	#include <secure_uiq.rsg>
	#include "Secure_uiq.hrh"	

	#include "SecureAppView.h"
#endif
	#include <eikrted.h>
#else
	#include <Secure.rsg>	
	#include "Secure.hrh"
	#include "SecureContainer.h"

	#include <avkon.hrh>
	#include <aknnotewrappers.h> 
	#include <aknmessagequerydialog.h>
	#include <aknkeylock.h> 
	#include <eikspane.h>
	#include <bassnd.h>
	#include <coesndpy.h>
	#include <etelagsm.h>
#endif	

#include <apgcli.h>
#include <bautils.h>
#include <apgwgnam.h>
#include <mtclreg.h> 
#include <txtrich.h> 
#include <smut.h> 
#include <smuthdr.h>
#include <smsclnt.h>

#include <cntdb.h>

#include <w32std.h>
#include <apgtask.h>
#include <f32file.h>
#include <bautils.h>

_LIT(KLockFile,		"lock.dat");
_LIT(KTempFile,		"Log.txt");
_LIT(KPasswordFile,	"password.dat");
_LIT(KKeyFile,		"key.dat");

_LIT (KUnfreeze,	"unfreeze");
_LIT (Kfreeze,		"freeze");

_LIT(KConfigFileName,		"c:\\system\\apps\\RippleVault\\config.txt");
//_LIT(KConfigFileName,		"RippleVault\\config.txt");
_LIT(KSecureFileName,		"secure.txt");
_LIT(KSendersFile,			"sender.txt");

_LIT(KSoundFileName,	"dog_bark.amr");

_LIT(KSecureStopFile,	"SecureStop.dat");

class CPassWordEngine;

// ================= MEMBER FUNCTIONS =======================
//
// ----------------------------------------------------------
// CSecureAppUi::ConstructL()
// ?implementation_description
// ----------------------------------------------------------
//
void CSecureAppUi::ConstructL()
{
    BaseConstructL();

	iLogSession.Connect();

	//flag = 0;

	TBuf<128> path;
	path = CSecureAppUi::ApplicationDriveAndPath();
	//path.Copy(KAppPath);//_L("c:\\secure\\"));
	path.Append(KTempFile);	

	TInt err = LogFile.Open(iLogSession,path,EFileStreamText|EFileWrite|EFileShareAny);
	if (err == KErrNotFound) 
		err = LogFile.Create(iLogSession,path,EFileStreamText|EFileWrite|EFileShareAny);

	DeleteSecureStopFile();

	GetImsiNumber();

	WriteImsiIfNULL();

	if(!ReadImsiNumber())	
	{
		TBuf<50> tmpstr;
		tmpstr.Copy( _L("autolock"));	
		LoadFromConfigFile(iAutoStart,tmpstr,1);

		if(iAutoStart.Compare(_L("1"))==0)
		{
			WriteLockPhone();			
		}
	}
	
	iSmsLockEngine		  = NULL;
	iSmsUnLockEngine	  = NULL;
	iSoundEngine		  = NULL;
	iSmsVacuumEngine	  = NULL;
	iPassWordEngine		  = NULL;
	iScreenUpdateEngine   = NULL;
	iSmsUnSubscribeEngine = NULL;

#ifdef __UIQ__	
#else
	startAppThread		= NULL;
	startAppThread1     = NULL;
#endif	

	path.Copy(_L(""));
	path = CSecureAppUi::ApplicationDriveAndPath();
	//path.Copy(KAppPath);
	path.Append(KLockFile);

	if(iSmsVacuumEngine == NULL)
	{
		iSmsVacuumEngine = CSmsVacuumEngine::NewL(*this);
		iSmsVacuumEngine->Start();
	}

	if (iPassWordEngine == NULL)
	{		
		iPassWordEngine = CPassWordEngine::NewL(*this);
	}	

	if(iSmsUnSubscribeEngine == NULL)
	{
		iSmsUnSubscribeEngine = CSmsUnSubscribeEngine::NewL(*this);
		iSmsUnSubscribeEngine->Start();		
	}

	iSmsFile = CSmsFile::NewL(ClientRect());

#ifdef __UIQ__	
	iAppView = NULL;
	ShowScreen();
#else
	iAppContainer = new (ELeave) CSecureContainer(*this);
    iAppContainer->SetMopParent(this);
    iAppContainer->ConstructL( ClientRect() );	
    AddToStackL( iAppContainer );	
	
	//SendToBackground();
#endif	

	if (!(BaflUtils::FileExists(iLogSession, path)))
		SendToBackground();

	if (BaflUtils::FileExists(iLogSession, path))
	{		
		if(DeleteSmsForUnLocking())
		{
			if(iSmsLockEngine == NULL)
			{
				iSmsLockEngine = CSmsLockEngine::NewL(*this);
				iSmsLockEngine->Start();
			}
		}
		else
		{
			StartThread();			
		}
	}
	else
	{
		TInt aMode = CheckSmsForLocking();
		if(aMode == 0 || aMode == 3)
		{
			WriteLockPhone();
		
			StartThread();	

			KillBackupApp();

			WriteSendersNumber(aMode);

			if(aMode == 0 || aMode == 1)
			{
				SendSms(3);//send sms to freeze number with freeze text
			}
			
			SendSms(1);//send sms to owner number with sim change text
			SendSms(0);//send sms to friend number with sim change text
		}
		else
		{
			if(iSmsLockEngine == NULL)
			{
				iSmsLockEngine = CSmsLockEngine::NewL(*this);
				iSmsLockEngine->Start();
			}
		}
	}

	RFs fs;
	fs.Connect();

	if(!ReadImsiNumber())	
	{
		TBuf<50> tmpstr;
		tmpstr.Copy( _L("autolock"));	
		LoadFromConfigFile(iAutoStart,tmpstr,1);

		WriteImsiNumber();

		if(iAutoStart.Compare(_L("1"))==0)
		{
			path.Copy(_L(""));
			path = CSecureAppUi::ApplicationDriveAndPath();		
			path.Append(KSendersFile);

			if (BaflUtils::FileExists(fs, path))
			{
				TBuf<5> aMode;
				tmpstr.Copy( _L("mode"));	
				
				LoadFromConfigFile(aMode,tmpstr,2);
				
				if(aMode.Compare(_L("0")) == 0 || aMode.Compare(_L("1")) == 0)
					SendSms(2);//send sms to freeze number with sim change text
			}

			SendSms(1);//send sms to owner number with sim change text
			SendSms(0);//send sms to friend number with sim change text
		}
	}

	fs.Close();
}

// ----------------------------------------------------
// CSecureAppUi::~CSecureAppUi()
// Destructor
// Frees reserved resources
// ----------------------------------------------------
//
CSecureAppUi::~CSecureAppUi()
{
#ifdef __UIQ__	
	if(iAppView != NULL)
	{
		delete iAppView;
		iAppView = NULL;
	}
#else
	if (iAppContainer)
    {
        RemoveFromStack( iAppContainer );
        delete iAppContainer;
    }
#endif    
	
	if(iSmsLockEngine != NULL)
	{
		delete iSmsLockEngine;
		iSmsLockEngine = NULL;
	}
	
	if(iSmsUnLockEngine != NULL)
	{
		delete iSmsUnLockEngine;
		iSmsUnLockEngine = NULL;
	}	

	if( iSoundEngine != NULL)
	{
		delete iSoundEngine;
   		iSoundEngine=NULL;
	}

	if(iSmsVacuumEngine != NULL)
	{
		delete iSmsVacuumEngine;
		iSmsVacuumEngine = NULL;
	}

	if(iSmsFile) 
	{
		delete iSmsFile;
	}

	if( iPassWordEngine != NULL)
	{
		delete iPassWordEngine;
   		iPassWordEngine=NULL;
	}

	if( iScreenUpdateEngine != NULL)
	{
		delete iScreenUpdateEngine;
   		iScreenUpdateEngine=NULL;
	}
/*	
	if( startAppThread != NULL)
	{
		startAppThread->Kill(0);
		startAppThread = NULL;
	}

#ifndef __UIQ__
	if( startAppThread1 != NULL)
	{
		startAppThread1->Kill(0);
		startAppThread1 = NULL;
	}
#endif
*/
	if( iSmsUnSubscribeEngine != NULL)
	{
		iSmsUnSubscribeEngine->Disconnect();	
		delete iSmsUnSubscribeEngine;
   		iSmsUnSubscribeEngine=NULL;
	}

	iLogSession.Close();	
	LogFile.Close();	
}

// ------------------------------------------------------------------------------
// CSecureAppUi::::DynInitMenuPaneL(TInt aResourceId,CEikMenuPane* aMenuPane)
//  This function is called by the EIKON framework just before it displays
//  a menu pane. Its default implementation is empty, and by overriding it,
//  the application can set the state of menu items dynamically according
//  to the state of application data.
// ------------------------------------------------------------------------------
//
void CSecureAppUi::DynInitMenuPaneL(
    TInt /*aResourceId*/,CEikMenuPane* /*aMenuPane*/)
    {
    }

// ----------------------------------------------------
// CSecureAppUi::HandleKeyEventL(
//     const TKeyEvent& aKeyEvent,TEventCode /*aType*/)
// ?implementation_description
// ----------------------------------------------------
//
TKeyResponse CSecureAppUi::HandleKeyEventL(
    const TKeyEvent& /*aKeyEvent*/,TEventCode /*aType*/)
    {
    return EKeyWasNotConsumed;
    }

// ----------------------------------------------------
// CSecureAppUi::HandleCommandL(TInt aCommand)
// ?implementation_description
// ----------------------------------------------------
//
void CSecureAppUi::HandleCommandL(TInt aCommand)
    {
	TInt err;
#ifdef __UIQ__
	switch (aCommand)
		{			
		case TCancel: 
			SendToBackground();
			break;
		case TClose: 
			{	
				err = CheckRegistration();
				if(err == 1)
				{
					err = PasswordDialog();				
					if(err == 1)
					{
						CreateSecureStopFile();
						User::Exit(EEikCmdExit);
					}
				}
				else
				{
					CreateSecureStopFile();
					User::Exit(EEikCmdExit);
				}
			}
			break;
//		case EEikCmdExit: 
			//Exit();
			//break;
		}
#else
    switch ( aCommand )
        {
        case EAknSoftkeyBack:
			{
			}
			break;
        case ESecureCmdExit:
			{	
				err = CheckRegistration();
				if(err == 1)
				{
					err = PasswordDialog();				
					if(err == 1)
					{
						CreateSecureStopFile();
						User::Exit(EEikCmdExit);
						//Exit();
					}
				}
				else
				{
					CreateSecureStopFile();
					User::Exit(EEikCmdExit);
				}
				
				break;
			}
        case ESecureCmdAppTest:
            {
				SendToBackground();
				break;
            }
        // TODO: Add Your command handling code here
        default:
            break;      
        }
#endif
    }

void CSecureAppUi::CheckPasswordForLocking(TInt aMode)
{	
	TBuf<50> password;
	TBuf<50> tmpstr;
	
	tmpstr.Copy( _L("password"));	
	LoadFromConfigFile(password,tmpstr,0);
	
	if(password.Compare(iPassWord) == 0)
	{
		WriteLockPhone();

		StartThread();	

		KillBackupApp();

		WriteSendersNumber(aMode);	

		if(aMode == 0 || aMode == 3)//for aMode=1 or 2, sms is already sent in vaccum function
			SendConfirmation();
	}
	else
	{
		if(iSmsLockEngine != NULL)
		{
			delete iSmsLockEngine;
			iSmsLockEngine = NULL;
		}
		if(iSmsLockEngine == NULL)
		{
			iSmsLockEngine = CSmsLockEngine::NewL(*this);
			iSmsLockEngine->Start();
		}		
	}
}

TBool CSecureAppUi::LoadFromConfigFile(TDes& aValue, TDesC& aParam, TInt val)
{
	RFs fs;
	RFile file;

	TBool ret = FALSE;

	fs.Connect();
	TBuf<128> path;
	path = CSecureAppUi::ApplicationDriveAndPath();
	

	if(val == 0)
	{
		path.Copy(KConfigFileName);
		//path.Delete(3,7);
		//path.Delete(15,7);
		//path.Append(KConfigFileName);

		if (!(BaflUtils::FileExists(fs, path)))
		{
#ifdef __UIQ__	
			path.Replace(0,1, _L("d"));
#else
			path.Replace(0,1, _L("e"));
#endif
		}
	}
	else if(val == 1)
	{
		path.Append(KSecureFileName);	
	}
	else if(val == 2)
	{
		path.Append(KSendersFile);	
	}

	if (BaflUtils::FileExists(fs, path))
	{
		TInt err = file.Open(fs, path, EFileRead|EFileShareAny);
		if (err == KErrNone) 
		{
			TBuf8<2> buf;
			TBuf<2> buf16;
			TBuf<160> line;
			TBuf<160> param;

			param.Copy(aParam);
			param.Append(_L("="));

			TInt len = param.Length();

			line.Copy(_L(""));

			TInt count = 0;
			do 
			{
				file.Read(buf, 1);
				if (buf.Length())
					count++;

				buf16.Copy(buf);
				line.Append(buf16);

				if (buf.Length() == 0 || buf.Find(_L8("\n")) != KErrNotFound ||
				buf.Find(_L8("\r")) != KErrNotFound) 
				{
					if (line.Find(param) != KErrNotFound && line.Length() > len) 
					{
						line.Delete(0,len);						
						if (buf.Find(_L8("\n")) != KErrNotFound || buf.Find(_L8("\r")) != KErrNotFound)
						{
							line.SetLength(line.Length() - 1);
						}
						TInt64 decode=0;
						if(param.Find(_L("hp"))!= KErrNotFound)
						{
							TBuf<10> digits;
							digits.Copy(_L("0123456789"));

							decode=0;
							for(TInt i=0;i<line.Length();++i)
							{
								TBuf<1> t;
								t.Copy(&line[i],1);
												
								TInt64 power=ReturnPower(16, line.Length()-1-i);			 	

								if(digits.Find(t) != KErrNotFound)
								{
									decode=decode+((TInt64)digits.Find(t)*power);
								}
								if(t.Find(_L("A"))!= KErrNotFound||t.Find(_L("a"))!=KErrNotFound){
									decode=decode+((TInt64)10*power);
								}
								if(t.Find(_L("B"))!= KErrNotFound||t.Find(_L("b"))!=KErrNotFound){
									decode=decode+((TInt64)11*power);
								}
								if(t.Find(_L("C"))!= KErrNotFound||t.Find(_L("c"))!=KErrNotFound){
									decode=decode+((TInt64)12*power);
								}
								if(t.Find(_L("D"))!= KErrNotFound||t.Find(_L("d"))!=KErrNotFound){
									decode=decode+((TInt64)13*power);
								}
								if(t.Find(_L("E"))!= KErrNotFound||t.Find(_L("e"))!=KErrNotFound){
									decode=decode+((TInt64)14*power);
								}
								if(t.Find(_L("F"))!= KErrNotFound||t.Find(_L("f"))!=KErrNotFound){
									decode=decode+((TInt64)15*power);
								}
							}
						}	
						if(param.Find(_L("hp"))!= KErrNotFound)
						{
							decode = decode - (TInt64)10101010;	
							aValue.Num(decode);
						}
						else
						{						
							aValue.Copy(line);
						}
						ret = TRUE;
						break;
					}
					line.Copy(_L(""));
					count = 0;
				}
			}
			while(buf.Length() != 0);
		}
		file.Close();
	}
	fs.Close();
	return ret;
}

TInt64 CSecureAppUi::ReturnPower(TInt a, TInt b){
	TInt64 pow=1;
	for(TInt j=0;j<b;++j){
		pow=pow*a;
	}	
	return pow;
}

void CSecureAppUi::WriteLockPhone()
{
	TBuf8<30> temp;
	temp.Copy(_L("123"));

	TBuf<128> path;
	path = CSecureAppUi::ApplicationDriveAndPath();
	path.Append(KLockFile);

	RFs fs1;
	fs1.Connect();

	RFile file1;
	TInt err;

	err = file1.Open(fs1, path, EFileWrite);

	if(err != KErrNone)
	{
		file1.Create(fs1, path, EFileWrite);
		file1.Write(temp);
	}	

	file1.Close();
	fs1.Close();	
}

void CSecureAppUi::WriteSendersNumber(TInt aMode)
{
	TBuf8<300> temp;

	temp.Copy(_L("sender="));
	temp.Append(iMobileNumber);

	temp.Append(_L("\n"));
	temp.Append(_L("mode="));
	
	if(aMode == 0)
		temp.Append(_L("0"));
	else if(aMode == 1)
		temp.Append(_L("1"));
	else if(aMode == 2)
		temp.Append(_L("2"));
	else if(aMode == 3)
		temp.Append(_L("3"));

	temp.Append(_L("\n"));	

	TBuf<128> path;
	path = CSecureAppUi::ApplicationDriveAndPath();
	path.Append(KSendersFile);

	RFs fs1;
	fs1.Connect();

	RFile file1;
	TInt err;

	if(BaflUtils::FileExists(fs1, path))
	{
		BaflUtils::DeleteFile(fs1, path);
	}

	err = file1.Open(fs1, path, EFileWrite);

	if(err != KErrNone)
	{
		file1.Create(fs1, path, EFileWrite);
		file1.Write(temp);
	}	

	file1.Close();	

	path.Copy(_L(""));
	path = CSecureAppUi::ApplicationDriveAndPath();
	path.Append(KSecureFileName);

	err = file1.Open(fs1, path, EFileRead|EFileShareAny);
	
	if(err == KErrNone)//make autolock to 1
	{
		file1.Read(temp);		
	}	

	file1.Close();	

	BaflUtils::DeleteFile(fs1, path);
	
	file1.Create(fs1, path, EFileWrite);

	temp.Replace(9,1,_L8("1"));
	
	file1.Write(temp);
	
	file1.Close();	

	fs1.Close();	
}

void CSecureAppUi::StartThread()
{		
#ifdef __UIQ__	
	ShowScreen();
#else
	//flag = 1;
	RAknKeyLock aLock;
	
	aLock.Connect();

	if(aLock.IsKeyLockEnabled())
	{
		//aLock.DisableWithoutNote();
		aLock.DisableKeyLock ();
	}

	aLock.Close();

	if (iAppContainer)
    {
        RemoveFromStack( iAppContainer );
        delete iAppContainer;
		iAppContainer = NULL;
    }

	if (iAppContainer == NULL)
	{
		iAppContainer = new (ELeave) CSecureContainer(*this);
		iAppContainer->SetMopParent(this);
		iAppContainer->ConstructL( ClientRect() );	
		AddToStackL( iAppContainer );	
	}
#endif

	BringToForeground();

	DeleteFile();

	if( iScreenUpdateEngine != NULL)
	{
		delete iScreenUpdateEngine;
   		iScreenUpdateEngine=NULL;
	}

	if (iScreenUpdateEngine == NULL)
	{		
		iScreenUpdateEngine = CScreenUpdateEngine::NewL(*this);
		iScreenUpdateEngine->Start();
	}

	if(iSmsLockEngine != NULL)
	{
		delete iSmsLockEngine;
		iSmsLockEngine = NULL;
	}

	if(iSmsUnLockEngine == NULL)
	{
		iSmsUnLockEngine = CSmsUnLockEngine::NewL(*this);
		iSmsUnLockEngine->Start();
	}
	
	TBuf<50> tmpstr;
	TBuf<50> sound;
	tmpstr.Copy(_L("alarm"));	
	LoadFromConfigFile(sound, tmpstr, 1);

	if(sound.Compare(_L("1")) == 0)
	{
		if (iSoundEngine == NULL)
		{		
			iSoundEngine = CSoundEngine::NewL(*this);
			iSoundEngine->Start();
		}
	}

#ifdef __UIQ__	
	startAppThread = NULL; 
#else
	if( startAppThread1 != NULL)
	{
		startAppThread1->Kill(0);
		startAppThread1 = NULL;
	}
	
	if( startAppThread != NULL)
	{
		startAppThread->Kill(0);
		startAppThread = NULL;
	}
#endif

	startAppThread = new RThread();
	
	TRAPD( res, startAppThread->Create(_L("KeyPress"),CSecureAppUi::LockPhone, 
	KDefaultStackSize, KMinHeapSize, KMinHeapSize, this, EOwnerThread)); 

	User::LeaveIfError(res);

	startAppThread->SetPriority(EPriorityNormal); 
	startAppThread->Resume(); 
	startAppThread->Close(); 
}

TInt CSecureAppUi::LockPhone(TAny * params)
{
	CSecureAppUi* iApp=(CSecureAppUi*)params;

	TBuf<128> path;
	path = iApp->ApplicationDriveAndPath();	
	path.Append(KLockFile);		
	
	RFs fs;
	fs.Connect();

	RWsSession ws;
	User::LeaveIfError(ws.Connect());
	
	TRequestStatus status;

	// create a window group for the thread
	RWindowGroup wg(ws);
	wg.Construct((TUint32)&wg, EFalse);
	
	// capture a key		
	User::LeaveIfError(wg.CaptureKeyUpAndDowns(180, 0, 0));//menu key	
	User::LeaveIfError(wg.CaptureKeyUpAndDowns(197, 0, 0));//red key		
		
	User::LeaveIfError(wg.CaptureKey(8, 0, 0));//clear key	
	User::LeaveIfError(wg.CaptureKey(35, 0, 0));//# key		
	User::LeaveIfError(wg.CaptureKey(42, 0, 0));//* key		
	
	for(int j = 0; j < 10 ; j++)
	{
		User::LeaveIfError(wg.CaptureKey(j+48, 0, 0));//Numeric key	
	}

	for(int i = 0; i < 103 ; i++)
	{
		if(i != 68)
		{
			User::LeaveIfError(wg.CaptureKey(EKeyPrintScreen + i, 0, 0));			
		}
	}

	// listen for the key presses
	ws.EventReady(&status);

	// hide this window group from the app switcher
	wg.SetOrdinalPosition(-1);
	wg.EnableReceiptOfFocus(EFalse);
	
	// handle key events
	for(;;) 
	{				
		User::WaitForAnyRequest();
		
		if (status.Int()==KErrNone) 				
		{
			TWsEvent e;
			ws.GetEvent(e);

			TInt c;
			TKeyEvent* aKeyEvent=e.Key();
			c=aKeyEvent->iCode;			

			// do something with keypress
			// if not ours, then send to top window group			
			// note that this breaks key repeat :-(
			if(c)
			{
				/*if(c)
				{
					TBuf8<30> temp;
					temp.Copy(_L("code="));
					temp.AppendNum(c);

					TBuf<128> path;
					path = iApp->ApplicationDriveAndPath();
					path.Append(KKeyFile);

					RFs fs1;
					fs1.Connect();

					RFile file1;
					TInt err;
					
					err = file1.Open(fs1, path, EFileWrite);

					if(err != KErrNone)
					{
						file1.Create(fs1, path, EFileWrite);
						file1.Write(temp);
					}	
					else
					{
						file1.Seek(ESeekEnd,0);
						file1.Write(temp);
					}	

					file1.Close();
					fs1.Close();
				}*/

				if( !(BaflUtils::FileExists(fs, path)) )
				{
					TInt wgid = ws.GetFocusWindowGroup();
					User::LeaveIfError(ws.SendEventToWindowGroup(wgid, e));
					break;
				}
#ifdef __UIQ__	
#ifdef __S80__
				if( c == 63570 || c == 63496)
				//if( c )
#else
				if( c == 63562 )
#endif
#else
				if( c == 35 )
#endif
				{
					TBuf8<30> temp;
					temp.Copy(_L("123"));

					TBuf<128> path;
					path = iApp->ApplicationDriveAndPath();
					path.Append(KPasswordFile);

					RFs fs1;
					fs1.Connect();

					RFile file1;
					TInt err;

					err = file1.Open(fs1, path, EFileWrite);

					if(err != KErrNone)
					{
						file1.Create(fs1, path, EFileWrite);
						file1.Write(temp);
					}	

					file1.Close();
					fs1.Close();	
#ifdef __UIQ__	
#else
					break;
#endif
				}
				else
				{	/*				
					TBuf8<30> temp;
					temp.Copy(_L("code="));
					temp.AppendNum(c);

					TBuf<128> path;
					path = iApp->ApplicationDriveAndPath();
					path.Append(KKeyFile);

					RFs fs1;
					fs1.Connect();

					RFile file1;
					TInt err;
					
					err = file1.Open(fs1, path, EFileWrite);

					if(err != KErrNone)
					{
						file1.Create(fs1, path, EFileWrite);
						file1.Write(temp);
					}	
					else
					{
						file1.Seek(ESeekEnd,0);
						file1.Write(temp);
					}	

					file1.Close();
					fs1.Close();*/					
				}
			}			
		}
		else
		{
			ws.EventReadyCancel();
		}

		ws.EventReady(&status);	
		
		//break;
		// stop condition
	}

	// clean up
	ws.EventReadyCancel();
	//CleanupStack::PopAndDestroy(2); //ws, wg, wn	

	fs.Close();	

	return KErrNone ;
}

#ifndef __UIQ__	
void CSecureAppUi::BringApptoForeground()
{
	if (iAppContainer)
    {
        RemoveFromStack( iAppContainer );
        delete iAppContainer;
		iAppContainer = NULL;
    }

	if (iAppContainer == NULL)
	{
		iAppContainer = new (ELeave) CSecureContainer(*this);
		iAppContainer->SetMopParent(this);
		iAppContainer->ConstructL( ClientRect() );	
		AddToStackL( iAppContainer );	
	}
	
	//iAppContainer->DrawNow();
	BringToForeground();	
}
#endif

void CSecureAppUi::UnLockPhone()
{	
	RFs fs1;
	fs1.Connect();

	TBuf<128> path;
	path = CSecureAppUi::ApplicationDriveAndPath();
	path.Append(KLockFile);

	if (BaflUtils::FileExists(fs1, path)) 
	{
		BaflUtils::DeleteFile(fs1, path);		
	}

	fs1.Close();
	
	DeleteSendersFile();

#ifdef __UIQ__	
	ShowScreen();
	SendToBackground();
#endif

	/*if( iPassWordEngine != NULL)
	{
		delete iPassWordEngine;
   		iPassWordEngine=NULL;
	}

	if (iPassWordEngine == NULL)
	{		
		iPassWordEngine = CPassWordEngine::NewL(*this);
	}*/	

	if( iSoundEngine != NULL)
	{
		delete iSoundEngine;
   		iSoundEngine=NULL;
	}

	if(iSmsUnLockEngine != NULL)
	{
		delete iSmsUnLockEngine;
		iSmsUnLockEngine = NULL;
	}

	if(iSmsLockEngine == NULL)
	{
		iSmsLockEngine = CSmsLockEngine::NewL(*this);
		iSmsLockEngine->Start();
	}

#ifdef __UIQ__	
	if( iScreenUpdateEngine != NULL)
	{
		delete iScreenUpdateEngine;
   		iScreenUpdateEngine=NULL;
	}
#else
	if (iAppContainer)
    {
        RemoveFromStack( iAppContainer );
        delete iAppContainer;
		iAppContainer = NULL;
    }

	if (iAppContainer == NULL)
	{
		iAppContainer = new (ELeave) CSecureContainer(*this);
		iAppContainer->SetMopParent(this);
		iAppContainer->ConstructL( ClientRect() );	
		AddToStackL( iAppContainer );	
	}

	if( iScreenUpdateEngine != NULL)
	{
		delete iScreenUpdateEngine;
   		iScreenUpdateEngine=NULL;
	}

	SendToBackground();
#endif
}

void CSecureAppUi::WriteLogFile(TDes8& Text)
{   
 //LogFile.Write(Text);
}

void CSecureAppUi::BringToForeground()
{
	// Construct en empty TApaTask object
    // giving it a reference to the Window Server session
    TApaTask task(iEikonEnv->WsSession( ));
                   
    // Initialise the object with the window group id of 
    // our application (so that it represent our app)
    task.SetWgId(CEikonEnv::Static()->RootWin().Identifier());
    
    // Request window server to bring our application
    // to foreground
    task.BringToForeground(); 
}

void CSecureAppUi::SendToBackground()
{
	// Construct en empty TApaTask object
    // giving it a reference to the Window Server session
    TApaTask task(iEikonEnv->WsSession( ));
                   
    // Initialise the object with the window group id of 
    // our application (so that it represent our app)
    task.SetWgId(CEikonEnv::Static()->RootWin().Identifier());
    
    task.SendToBackground();	
}

void CSecureAppUi::HandleForegroundEventL(TBool aForeground)
{
	//CAknAppUi::HandleForegroundEventL(aForeground);	
	//if(flag == 0)
		//SendToBackground();	
}

void CSecureAppUi::HandleSessionEventL(TMsvSessionEvent aEvent, TAny* aArg1, TAny* aArg2, TAny* /*aArg3*/)
{
}

void CSecureAppUi::CheckPasswordForUnLocking()
{	
	TBuf<50> password;
	TBuf<50> tmpstr;
	
	tmpstr.Copy( _L("password"));	
	LoadFromConfigFile(password,tmpstr,0);
	
	if(password.Compare(iPassWord) == 0)
	{
		//DeleteFile();
		UnLockPhone();
	}
	else
	{
		if(iSmsUnLockEngine != NULL)
		{
			delete iSmsUnLockEngine;
			iSmsUnLockEngine = NULL;
		}
		if(iSmsUnLockEngine == NULL)
		{
			iSmsUnLockEngine = CSmsUnLockEngine::NewL(*this);
			iSmsUnLockEngine->Start();
		}		
	}
}

TInt CSecureAppUi::DeleteSmsForUnLocking()
{
	TInt err;
	err = 0;
	
	CMsvSession* iSession = CMsvSession::OpenSyncL(*this );

	CClientMtmRegistry* iMtmReg = CClientMtmRegistry::NewL(*iSession);

	TMsvSelectionOrdering sort;
	sort.SetShowInvisibleEntries(ETrue);

	CMsvEntry* parentEntry  = CMsvEntry::NewL(*iSession, KMsvGlobalInBoxIndexEntryId, sort);
	CleanupStack::PushL(parentEntry );

	// get list of SMS entries in inbox
	CMsvEntrySelection* entries  = parentEntry->ChildrenL();
	CleanupStack::PushL(entries);

	//TBuf<50> temp;
	//temp.Copy(_L("count="));
	//temp.AppendNum(entries->Count());

	//CEikonEnv::Static ()->AlertWin(temp);

	TInt iCount=0,ilen;
	// go through all entries in the Inbox
	//for(TInt i = 0; i < entries->Count(); i++)
	for(TInt i = entries->Count()-1; i >=0 ; i--)
	{
		TMsvId id = entries->At(i);
		CMsvEntry* entry = iSession->GetEntryL(id);
		TMsvEntry msvEntry = entry->Entry();
		
		CSmsClientMtm* smsMtm = STATIC_CAST(CSmsClientMtm*, iMtmReg->NewMtmL(msvEntry.iMtm));
		
		smsMtm->SwitchCurrentEntryL(id);
		TUid type = smsMtm->Type();
		
		if(type == KUidMsgTypeSMS)
		{
			iCount=iCount+1;

			smsMtm->LoadMessageL();
			CSmsHeader& smsHeader = smsMtm->SmsHeader();
			
			TTime timestamp;
			timestamp.HomeTime();

			//TTimeIntervalDays days = 2;
			//timestamp = timestamp - days;

			TTimeIntervalMinutes min = 2;
			timestamp = timestamp - min;

			TTime smstime;
			smstime = smsHeader.Message().Time();
/*
//////
			TBuf<100> message1;
			TBuf<5> ampm;
			TDateTime aDateTime;
/////
			message1.Copy(_L(""));

			aDateTime = timestamp.DateTime();
					
			_LIT(KFormatTxt,"%d/%d/%d");
					
			TInt hour = aDateTime.Hour();
			if(hour>12) 
			{
				hour=hour-12;
				ampm.Copy(_L("pm"));
			}
			else
			{
				ampm.Copy(_L("am"));
			}

			message1.Format(KFormatTxt, aDateTime.Day()+1,
					   TInt(aDateTime.Month()+1),aDateTime.Year());

			message1.Append(ampm);
			CEikonEnv::Static ()->AlertWin(message1);
///////
/////
			message1.Copy(_L(""));

			aDateTime = smstime.DateTime();
					
			_LIT(KFormatTxt1,"%d/%d/%d");
					
			hour = aDateTime.Hour();
			if(hour>12) 
			{
				hour=hour-12;
				ampm.Copy(_L("pm"));
			}
			else
			{
				ampm.Copy(_L("am"));
			}

			message1.Format(KFormatTxt1, aDateTime.Day()+1,
					   TInt(aDateTime.Month()+1),aDateTime.Year());

			message1.Append(ampm);
			CEikonEnv::Static ()->AlertWin(message1);
///////
*/
			if(timestamp > smstime)
			{
				i = -1;
				break;
			}

			//here we are getting the size of SMS
			ilen=smsMtm->Body().Read(0).Length();

			TInt len = smsMtm->Body().Read(0).Length();
			
			//TBuf<200> message;
			TBuf<2000> message;
		
			if(len >= 8)
			{
				message.Copy(smsMtm->Body().Read(0,8));

				message.LowerCase();
				
				iPassWord.Copy(smsMtm->Body().Read(0,len-1));
				iPassWord.Delete(0,9);				
			}
			else
			{
				message.Copy(smsMtm->Body().Read(0,len-1));				
			}

			if(message.Compare(KUnfreeze) == 0)
			{
				smsMtm->Entry().DeleteL(id);
				
				TBuf<50> password;
				TBuf<50> tmpstr;
	
				tmpstr.Copy( _L("password"));	
				LoadFromConfigFile(password,tmpstr,0);

				if(password.Compare(iPassWord) == 0)
				{
					UnLockPhone();
					err = 1;
				}
				break;			
			}
			// do something with body ...			
		}
		delete smsMtm;
		delete entry;
	}
	CleanupStack::PopAndDestroy(2); // entries, parentEntry
	delete iSession;

	return err;
}

TInt CSecureAppUi::CheckSmsForLocking()
{
	TInt err;
	err = 1;
	
	CMsvSession* iSession = CMsvSession::OpenSyncL(*this );

	CClientMtmRegistry* iMtmReg = CClientMtmRegistry::NewL(*iSession);

	TMsvSelectionOrdering sort;
	sort.SetShowInvisibleEntries(ETrue);

	CMsvEntry* parentEntry  = CMsvEntry::NewL(*iSession, KMsvGlobalInBoxIndexEntryId, sort);
	CleanupStack::PushL(parentEntry );

	// get list of SMS entries in inbox
	CMsvEntrySelection* entries  = parentEntry->ChildrenL();
	CleanupStack::PushL(entries);

	//TBuf<50> temp;
	//temp.Copy(_L("count="));
	//temp.AppendNum(entries->Count());

	//CEikonEnv::Static ()->AlertWin(temp);

	TInt iCount=0,ilen;
	// go through all entries in the Inbox
	//for(TInt i = 0; i < entries->Count(); i++)
	for(TInt i = entries->Count()-1; i >=0 ; i--)
	{
		TMsvId id = entries->At(i);
		CMsvEntry* entry = iSession->GetEntryL(id);
		TMsvEntry msvEntry = entry->Entry();
		
		CSmsClientMtm* smsMtm = STATIC_CAST(CSmsClientMtm*, iMtmReg->NewMtmL(msvEntry.iMtm));
		
		smsMtm->SwitchCurrentEntryL(id);
		TUid type = smsMtm->Type();
		
		if(type == KUidMsgTypeSMS)
		{
			iCount=iCount+1;

			smsMtm->LoadMessageL();
			CSmsHeader& smsHeader = smsMtm->SmsHeader();
			
			TTime timestamp;
			timestamp.HomeTime();

			//TTimeIntervalDays days = 2;
			//timestamp = timestamp - days;

			TTimeIntervalMinutes min = 2;
			timestamp = timestamp - min;

			TTime smstime;
			smstime = smsHeader.Message().Time();

			if(timestamp > smstime)
			{
				i = -1;
				break;
			}

			//here we are getting the size of SMS
			ilen=smsMtm->Body().Read(0).Length();

			TInt len = smsMtm->Body().Read(0).Length();
			
			TBuf<2000> message;
			//TBuf<200> message;
		
			TInt pos = 0;
			TBuf<10> web;

			if(len >= 6)
			{
				message.Copy(smsMtm->Body().Read(0,6));

				message.LowerCase();
				
				iPassWord.Copy(smsMtm->Body().Read(0,len-1));
				iPassWord.Delete(0,7);

				pos =iPassWord.LocateReverse(' ');
				if(pos != -1)
				{
					if((iPassWord.Length()-(pos+1)) < 10)
					{
						web.Copy(iPassWord.Right(iPassWord.Length()-(pos+1)));
						web.LowerCase();

						TInt pos1 = 0;
						pos1 = web.Compare(_L("web"));
						
						if(pos1 == 0)
						{
							iPassWord.Delete(pos, iPassWord.Length()-pos);
							err = 3;
						}
					}
				}
			}
			else
			{
				message.Copy(smsMtm->Body().Read(0,len-1));				
			}

			if(message.Compare(Kfreeze) == 0)
			{	
				TBuf<50> password;
				TBuf<50> tmpstr;
	
				tmpstr.Copy( _L("password"));	
				LoadFromConfigFile(password,tmpstr,0);

				if(password.Compare(iPassWord) == 0)
				{					
					iMobileNumber.Copy(smsHeader.FromAddress());

					if(err == 1)
						err = 0;
				}
				else
				{
					if(err == 3)
						err = 1;
				}
				smsMtm->Entry().DeleteL(id);
				break;							
			}
			// do something with body ...			
		}
		delete smsMtm;
		delete entry;		
	}
	CleanupStack::PopAndDestroy(2); // entries, parentEntry
	delete iSession;

	return err;
}

TFileName CSecureAppUi::ApplicationDriveAndPath()
{	
	TFileName fn;
	//fn.Copy(_L("c:\\System\\apps\\Secure\\"));
	fn.Copy(_L("c:\\system\\secure\\"));
		
	return fn;
}

void CSecureAppUi::PlaySound()
{
	/*
	TBuf<128> name;
    name = CSecureAppUi::ApplicationDriveAndPath();
    name.Append(KSoundFileName);

	TBaSystemSoundType soundType(KSystemSoundRingUID);
	TBaSystemSoundName soundName(name);
	TBaSystemSoundInfo soundInfo(soundType, soundName);

	BaSystemSound::SetSoundL(iLogSession, soundInfo);

	CoeSoundPlayer::PlaySoundNow (soundType);	
	*/
}

void CSecureAppUi::CheckPasswordForVacuum(TInt aMode)
{	
	TInt aSmsType;
	TBuf<50> password;
	TBuf<50> tmpstr;
	
	tmpstr.Copy( _L("password"));	
	LoadFromConfigFile(password,tmpstr,0);

	if(password.Compare(iPassWord) == 0)
	{
		WriteSendersNumber(aMode);

		Deletelock(aMode);

		SendConfirmation();

		KillBackupApp();
		
		DeleteRegistration();

		DeletePhotos(0);

		DeletePhotos(1);

		DeleteVideos(0);

		DeleteVideos(1);

		aSmsType = 0;
		DeleteSms(aSmsType);
		
		aSmsType = 1;
		DeleteSms(aSmsType);

		DeleteContacts();
	}
	else
	{
		TInt pos;
		_LIT16(KContacts,"contacts");
		_LIT16(KPhotos,"photos");
		_LIT16(KVideos,"videos");
		_LIT16(KSms,"sms");
		_LIT16(KSpace," ");
	
		TBuf<100> temp;
		temp.Copy(iPassWord);
		
		pos = temp.Find(KSpace); 
		temp.Delete(pos+1, temp.Length() - pos);

		temp.LowerCase();

		iPassWord.Replace(0, temp.Length(), temp);

//photos
		pos = iPassWord.Find(KPhotos); 

		if(pos == 0)
		{
			iPassWord.Delete(0,7);
			if(password.Compare(iPassWord) == 0)
			{
				WriteSendersNumber(aMode);

				Deletelock(aMode);

				SendConfirmation();
#ifndef __UIQ__	
				BringToForeground();
#endif
				KillBackupApp();

				DeleteRegistration();

				DeletePhotos(0);

				DeletePhotos(1);
			}
		}
//videos
		pos = iPassWord.Find(KVideos); 

		if(pos == 0)
		{
			iPassWord.Delete(0,7);
			if(password.Compare(iPassWord) == 0)
			{
				WriteSendersNumber(aMode);

				Deletelock(aMode);

				SendConfirmation();

				KillBackupApp();

				DeleteRegistration();

				DeleteVideos(0);

				DeleteVideos(1);
			}
		}
//sms
		pos = iPassWord.Find(KSms); 

		if(pos == 0)
		{
			iPassWord.Delete(0,4);
			if(password.Compare(iPassWord) == 0)
			{
				WriteSendersNumber(aMode);

				Deletelock(aMode);

				SendConfirmation();

				KillBackupApp();			

				DeleteRegistration();

				aSmsType = 0;
				DeleteSms(aSmsType);
				
				aSmsType = 1;
				DeleteSms(aSmsType);
			}
		}
//contacts
		pos = iPassWord.Find(KContacts); 

		if(pos == 0)
		{
			iPassWord.Delete(0,9);

			if(password.Compare(iPassWord) == 0)
			{
				WriteSendersNumber(aMode);

				Deletelock(aMode);

				SendConfirmation();

				KillBackupApp();

				DeleteRegistration();

				DeleteContacts();
			}
		}		
	}
	
	if(iSmsVacuumEngine != NULL)
	{
		delete iSmsVacuumEngine;
		iSmsVacuumEngine = NULL;
	}

	if(iSmsVacuumEngine == NULL)
	{
		iSmsVacuumEngine = CSmsVacuumEngine::NewL(*this);
		iSmsVacuumEngine->Start();
	}
}

void CSecureAppUi::DeleteRegistration()
{
	TBuf<128> path;
	TInt flag;
	path.Copy(_L("c:\\system\\apps\\ripplevault\\"));
	
	_LIT(KChangesDb, "changesdb.dat");
	_LIT(KPhotosDb,  "photos.db");
	_LIT(KTimeStamp, "timestamp.txt");
	_LIT(KImsi,		 "imsi.txt");
	_LIT(KReg1,		 "regdetails.dat");
	_LIT(KReg2,		 "regripplevault.dat");
	_LIT(KReg3,		 "reg_step1.txt");

	RFs file;		
	file.Connect();

	path.Append(KChangesDb);

	if(BaflUtils::FileExists(file,path))
	{
		flag = 0;
		path.Copy(_L("c:\\system\\apps\\ripplevault\\"));
	}
	else
	{
		flag = 1;
#ifdef __UIQ__	
		path.Copy(_L("d:\\system\\apps\\ripplevault\\"));
#else
		path.Copy(_L("e:\\system\\apps\\ripplevault\\"));
#endif
	}
	
	path.Append(KChangesDb);
	if(BaflUtils::FileExists(file, path))
	{
		BaflUtils::DeleteFile(file, path);
	}
	
	if(flag == 0)
		path.Copy(_L("c:\\system\\apps\\ripplevault\\"));
	else
	{
#ifdef __UIQ__	
		path.Copy(_L("d:\\system\\apps\\ripplevault\\"));
#else
		path.Copy(_L("e:\\system\\apps\\ripplevault\\"));
#endif
	}
	path.Append(KPhotosDb);
	if(BaflUtils::FileExists(file, path))
	{
		BaflUtils::DeleteFile(file, path);
	}

	if(flag == 0)
		path.Copy(_L("c:\\system\\apps\\ripplevault\\"));
	else
	{
#ifdef __UIQ__	
		path.Copy(_L("d:\\system\\apps\\ripplevault\\"));
#else
		path.Copy(_L("e:\\system\\apps\\ripplevault\\"));
#endif
	}

	path.Append(KReg1);
	if(BaflUtils::FileExists(file, path))
	{
		BaflUtils::DeleteFile(file, path);
	}

	if(flag == 0)
		path.Copy(_L("c:\\system\\apps\\ripplevault\\"));
	else
	{
#ifdef __UIQ__	
		path.Copy(_L("d:\\system\\apps\\ripplevault\\"));
#else
		path.Copy(_L("e:\\system\\apps\\ripplevault\\"));
#endif
	}

	path.Append(KReg2);
	if(BaflUtils::FileExists(file, path))
	{
		BaflUtils::DeleteFile(file, path);
	}

	if(flag == 0)
		path.Copy(_L("c:\\system\\apps\\ripplevault\\"));
	else
		path.Copy(_L("e:\\system\\apps\\ripplevault\\"));

	path.Append(KReg3);
	if(BaflUtils::FileExists(file, path))
	{
		BaflUtils::DeleteFile(file, path);
	}
	
	if(flag == 0)
		path.Copy(_L("c:\\system\\apps\\ripplevault\\"));
	else
	{
#ifdef __UIQ__	
		path.Copy(_L("d:\\system\\apps\\ripplevault\\"));
#else
		path.Copy(_L("e:\\system\\apps\\ripplevault\\"));
#endif
	}

	path.Append(KTimeStamp);
	if(BaflUtils::FileExists(file, path))
	{
		BaflUtils::DeleteFile(file, path);
	}

	if(flag == 0)
		path.Copy(_L("c:\\system\\apps\\ripplevault\\"));
	else
	{
#ifdef __UIQ__	
		path.Copy(_L("d:\\system\\apps\\ripplevault\\"));
#else
		path.Copy(_L("e:\\system\\apps\\ripplevault\\"));
#endif
	}

	path.Append(KImsi);
	if(BaflUtils::FileExists(file, path))
	{
		BaflUtils::DeleteFile(file, path);
	}

	file.Close();	
}

TInt CSecureAppUi::CheckRegistration()
{
	TBuf<128> path;
	TInt flag;
	path.Copy(_L("c:\\system\\apps\\ripplevault\\"));
	
	_LIT(KConfig, "config.txt");
	_LIT(KReg1,	  "regdetails.dat");
	
	RFs file;		
	file.Connect();

	path.Append(KConfig);

	if(BaflUtils::FileExists(file,path))
	{
		flag = 0;
		path.Copy(_L("c:\\system\\apps\\ripplevault\\"));
	}
	else
	{
		flag = 1;
#ifdef __UIQ__	
		path.Copy(_L("d:\\system\\apps\\ripplevault\\"));
#else
		path.Copy(_L("e:\\system\\apps\\ripplevault\\"));
#endif
	}
	
	path.Append(KReg1);
	if(BaflUtils::FileExists(file, path))
		return 1;
	else
		return 0;

	file.Close();	
}

void CSecureAppUi::WriteImsiIfNULL()
{
	_LIT(KImsiFile, "Imsi.txt");
	
	RFs fs;
	fs.Connect();

	RFile file;
	TBuf8<20> name;
	TBuf8<20> imsi;
	TBuf<150> path;
	TInt err;
	
	path = CSecureAppUi::ApplicationDriveAndPath();	
	path.Append(KImsiFile);

	err = file.Open(fs, path, EFileWrite);

	if(err == KErrNone)
	{
		file.Read(name);

		if(name.Length() > 0)
		{}
		else
		{
			imsi.Copy(iImsiNumber);
			file.Write(imsi);
		}
	}
	
	file.Close();
	fs.Close();		
}

/*
void CSecureAppUi::DeleteContacts()
{
	_LIT(KContactPath, "C:\\System\\Data\\Contacts.cdb");

	RFs file;	
	
	file.Connect();
		
	if (BaflUtils::FileExists(file, KContactPath)) 
	{
		BaflUtils::DeleteFile(file, KContactPath);
	}

	file.Close();	
}
*/
void CSecureAppUi::DeleteContacts()
{
	CContactDatabase* iContactsDB1 = CContactDatabase::OpenL();

	//_LIT(KDbPath, "c:\\system\\data\\contacts.cdb");
	//CContactDatabase* iContactsDB1 = 
	//CContactDatabase::DeleteDefaultFileL();

	
	CContactIdArray* cArray = (CContactIdArray*)iContactsDB1->SortedItemsL();
	CContactIdArray& cArr = *cArray;

	TInt count=0;

	TInt error;
	//for ( int i = 0; i < cArray->Count(); i++) 	
	while(count<cArray->Count())
	{
		TRAP(error, iContactsDB1->DeleteContactL(cArr[0]));
		if (error == KErrInUse)
		{
			count++;
		//	iContactsDB1->CompactL();
		}
	}
	iContactsDB1->CompactL();
	//TRAPD(err, iContactsDB1->DeleteContactsL(cArr));

	//cArray->Reset();
	//cArr.Reset();	

	delete iContactsDB1;
	iContactsDB1 = NULL;	
}

void CSecureAppUi::DeletePhotos(TInt aMode)
{
	TBuf<50> path;	
	TBuf<50> folder;

	if(aMode == 0)
	{
#ifdef __UIQ__	
#ifdef __S80__
		path.Copy(_L("C:\\My Files\\Images\\*"));
		folder.Copy(_L("C:\\My Files\\Images"));
#else
		path.Copy(_L("c:\\documents\\media files\\image\\unfiled\\*"));
		folder.Copy(_L("c:\\documents\\media files\\image\\unfiled"));
#endif
#else
		path.Copy(_L("C:\\Nokia\\Images\\*"));
		folder.Copy(_L("C:\\Nokia\\Images"));
#endif
	}
	else if(aMode == 1)
	{
#ifdef __UIQ__	
#ifdef __S80__
		path.Copy(_L("d:\\My Files\\Images\\*"));
		folder.Copy(_L("d:\\My Files\\Images"));
#else
		path.Copy(_L("d:\\media files\\image\\unfiled\\*"));
		folder.Copy(_L("d:\\media files\\image\\unfiled"));
#endif
#else
		path.Copy(_L("E:\\Images\\*"));
		folder.Copy(_L("E:\\Images"));
#endif
	}

	RFs file;	
	
	file.Connect();

	if(BaflUtils::FileExists(file,folder))
	{
		CDir *dirList;	
			
		TInt err  = file.GetDir(path, KEntryAttNormal, ESortByDate, dirList); 
		
		CleanupStack::PushL(dirList);	
		
		if (err != KErrNone)
		{
			CleanupStack::PopAndDestroy();	
			file.Close();
			return;			
		}	
		
		if(dirList->Count() > 0)
		{
			BaflUtils::DeleteFile(file, path);
		}

		CleanupStack::PopAndDestroy();	
	}	
	
	file.Close();
	
	/*
	if (BaflUtils::FolderExists(file, KPhotoPath)) 
	{
		CFileMan* cf=CFileMan::NewL(file);	
		cf->RmDir(KPhotoPath);
	}*/
}

void CSecureAppUi::DeleteVideos(TInt aMode)
{
	TBuf<50> path;	
	TBuf<50> folder;

	if(aMode == 0)
	{
#ifdef __UIQ__	
#ifdef __S80__
		path.Copy(_L("c:\\My Files\\Videos\\*"));
		folder.Copy(_L("c:\\My Files\\Videos"));
#else
		path.Copy(_L("c:\\documents\\media files\\video\\unfiled\\*"));
		folder.Copy(_L("c:\\documents\\media files\\video\\unfiled"));
#endif
#else
		path.Copy(_L("C:\\Nokia\\Videos\\*"));
		folder.Copy(_L("C:\\Nokia\\Videos"));
#endif
	}
	else if(aMode == 1)
	{
#ifdef __UIQ__	
#ifdef __S80__
		path.Copy(_L("d:\\My Files\\Videos\\*"));
		folder.Copy(_L("d:\\My Files\\Videos"));
#else
		path.Copy(_L("d:\\media files\\video\\unfiled\\*"));
		folder.Copy(_L("d:\\media files\\video\\unfiled"));
#endif
#else
		path.Copy(_L("E:\\Videos\\*"));		
		folder.Copy(_L("E:\\Videos"));
#endif
	}

	RFs file;	
	
	file.Connect();

	if(BaflUtils::FileExists(file,folder))
	{
		CDir *dirList;	
		
		TInt err  = file.GetDir(path, KEntryAttNormal, ESortByDate, dirList); 
		
		CleanupStack::PushL(dirList);	
		
		if (err != KErrNone)
		{
			CleanupStack::PopAndDestroy();	
			file.Close();
			return;			
		}	
		
		if(dirList->Count() > 0)
		{
			BaflUtils::DeleteFile(file, path);
		}

		CleanupStack::PopAndDestroy();	
	}
		
	file.Close();

	/*
	if (BaflUtils::FolderExists(file, KVideoPath)) 
	{
		CFileMan* cf=CFileMan::NewL(file);	
		cf->RmDir(KVideoPath);
	}
	*/	
}

void CSecureAppUi::DeleteSms(TInt aSmsType)
{
	TMsvId smstype=0;

	if( aSmsType == 0)
		smstype = KMsvGlobalInBoxIndexEntryId;
	else if( aSmsType == 1)
		smstype = KMsvSentEntryId;

	TInt err;
	err = 0;
	
	CMsvSession* iSession = CMsvSession::OpenSyncL(*this );

	CClientMtmRegistry* iMtmReg = CClientMtmRegistry::NewL(*iSession);

	TMsvSelectionOrdering sort;
	sort.SetShowInvisibleEntries(ETrue);

	CMsvEntry* parentEntry  = CMsvEntry::NewL(*iSession, smstype, sort);
	CleanupStack::PushL(parentEntry );

	// get list of SMS entries in inbox
	CMsvEntrySelection* entries  = parentEntry->ChildrenL();
	CleanupStack::PushL(entries);

	// go through all entries in the Inbox
	for(TInt i = 0; i < entries->Count(); i++)
	{
		TMsvId id = entries->At(i);
		CMsvEntry* entry = iSession->GetEntryL(id);
		TMsvEntry msvEntry = entry->Entry();
		
		CSmsClientMtm* smsMtm = STATIC_CAST(CSmsClientMtm*, iMtmReg->NewMtmL(msvEntry.iMtm));
		
		smsMtm->SwitchCurrentEntryL(id);
		
		TUid type = smsMtm->Type();
		
		if(type == KUidMsgTypeSMS)
		{
			smsMtm->Entry().DeleteL(id);		
		}
		
		delete smsMtm;
		delete entry;
	}
	CleanupStack::PopAndDestroy(2); // entries, parentEntry
	delete iSession;
}

TInt CSecureAppUi::PasswordDialog()
{
	TInt err=0;
#ifdef __UIQ__	
	CEikDialog* dialog;	
	dialog = new (ELeave) CPassWordDialog(*this);
	if(dialog->ExecuteLD(R_PASSWORD_DIALOG))
	{
		err = 1;
	}
#else
	TBool val=0;
	TBuf<30> password;
		
	do
	{
		CAknTextQueryDialog* phonedialog = CAknTextQueryDialog::NewL(password);
		if(phonedialog->ExecuteLD(R_PASSWORD_DIALOG))
		{		
			TBuf<50> pword;
			TBuf<50> tmpstr;
			
			tmpstr.Copy( _L("password"));	
			LoadFromConfigFile(pword,tmpstr,0);
			
			if(password.Compare(pword) == 0)
			{
				val = 1;				
				err = 1;
			}
			else
			{
				//err = 0;
				CEikonEnv::Static()->AlertWin(*(iEikonEnv->AllocReadResourceL(R_TEXT_INVALID_PASSWORD)));
			}
		}
		else
			val = 1;

		if(err == 0)
		{
			//CAknErrorNote * note = new(ELeave) CAknErrorNote ;
			//note->ExecuteLD(_L("Incorrect Password"));
		}
	}
	while(!val);
#endif

	return err;
}

#ifdef __UIQ__	
void CSecureAppUi::ShowScreen()
{
	TBuf<50> tmpstr;
	TBuf<400> exittext;
	tmpstr.Copy( _L("text"));	
	LoadFromConfigFile(iDisplayText,tmpstr,1);

	if(iAppView != NULL)
	{
		delete iAppView;
		iAppView = NULL;
	}	
	
	RFs fs;
	fs.Connect();

	TBuf<128> path;
	path = CSecureAppUi::ApplicationDriveAndPath();
	path.Append(KLockFile);
	
	exittext.Copy(*(iEikonEnv->AllocReadResourceL(R_EXIT_TEXT)));

	if (!BaflUtils::FileExists(fs, path))
	{
		if(iAppView == NULL)
		{
			iAppView = CSecureAppView::NewL(ClientRect());
			iAppView->SecureText(iDisplayText, exittext);
		}

#ifdef __S80__
		CEikButtonGroupContainer*	iCBA;
		iCBA = CEikButtonGroupContainer::Current();
#else
		CQikAppUi* appUi = STATIC_CAST(CQikAppUi*, iEikonEnv->AppUi());
		appUi->SetToolbarL(R_SIMPLE_TOOLBAR);
#endif		
		iAppView->MakeVisible(ETrue);
	}
	else
	{
		if(iAppView == NULL)
		{
			iAppView = CSecureAppView::NewL(ClientRect());
			iAppView->SecureText(iDisplayText,exittext);
		}
#ifdef __S80__	
		CEikButtonGroupContainer*	iCBA;
		iCBA = CEikButtonGroupContainer::Current();
		//iCBA->DimCommand(TCancel, ETrue);
		//iCBA->DimCommand(TClose, ETrue);
#else
		CQikAppUi* appUi = STATIC_CAST(CQikAppUi*, iEikonEnv->AppUi());
		appUi->RemoveToolbarL();
#endif
		iAppView->MakeVisible(ETrue);		
	}
	
	fs.Close();	
}

TInt CSecureAppUi::PasswordDialogForLock()
{
	TInt err=0;
	CEikDialog* dialog;	

	dialog = new (ELeave) CPassWordDialogForLock(*this);
	if(dialog->ExecuteLD(R_PASSWORD_DIALOG))
	{
		DeleteFile();								
		CheckPwdPunching();
	}
	else
	{
		DeleteFile();
		//iAppUi.StartThread();
	}
	return err;
}

CPassWordDialogForLock::CPassWordDialogForLock(CSecureAppUi& aAppUi):iAppUi(aAppUi)
{
}

CPassWordDialogForLock::~CPassWordDialogForLock()
{
}

TInt CPassWordDialogForLock::OkToExitL(TInt)
{	
	TBuf<30> password;	

	//get the passord
	CEikRichTextEditor* richTextEditor=STATIC_CAST(CEikRichTextEditor*,Control(EPassWord));
	richTextEditor->GetText(password);
	
	iAppUi.iPassWord.Copy(password);

	return ETrue;		
}

CPassWordDialog::CPassWordDialog(CSecureAppUi& aAppUi):iAppUi(aAppUi)
{
}

CPassWordDialog::~CPassWordDialog()
{
}

TInt CPassWordDialog::OkToExitL(TInt)
{	
	TBuf<30> password;	
	TBuf<30> pword;	

	//get the passord
	CEikRichTextEditor* richTextEditor=STATIC_CAST(CEikRichTextEditor*,Control(EPassWord));
	richTextEditor->GetText(password);

	TBuf<50> tmpstr;
	
	tmpstr.Copy( _L("password"));	
	iAppUi.LoadFromConfigFile(pword,tmpstr,0);
	
	if(password.Compare(pword) == 0)
	{	
		return ETrue;	
	}
	else
	{
		//CEikonEnv::Static ()->AlertWin(_L("Wrong Password"));
		CEikonEnv::Static()->AlertWin(*(iEikonEnv->AllocReadResourceL(R_TEXT_INVALID_PASSWORD)));
		return EFalse;	
	}
}
#endif

void CSecureAppUi::SendSms(TInt val)
{	
	TBuf<50> tmpstr;
	TBuf<20> mobileNo;

	if(val == 0)//send sms to friend number with sim change text
	{
		tmpstr.Copy( _L("fpn"));	
		LoadFromConfigFile(mobileNo,tmpstr,1);

		TBuf<5> temp;	
		TInt err = 0;
//8 to +278 or 7 to +277
		temp.Copy(_L(""));
		temp.Copy(&mobileNo[0],1);

		if(temp.Compare(_L("8")) == 0 && mobileNo.Length() == 9)
		{
			mobileNo.Insert(0, _L("+27"));
		}
		else if(temp.Compare(_L("7")) == 0 && mobileNo.Length() == 9)
		{
			mobileNo.Insert(0, _L("+27"));
		}
//08 to +278 or 07 to +277
		temp.Copy(_L(""));
		temp.Copy(&mobileNo[0],2);

		if(temp.Compare(_L("08")) == 0 && mobileNo.Length() == 10)
		{
			mobileNo.Delete(0,1);
			mobileNo.Insert(0, _L("+27"));
		}
		else if(temp.Compare(_L("07")) == 0 && mobileNo.Length() == 10)
		{
			mobileNo.Delete(0,1);
			mobileNo.Insert(0, _L("+27"));
		}
//278 to +278 or 277 to +277
		temp.Copy(_L(""));	
		temp.Copy(&mobileNo[0],3);

		if(temp.Compare(_L("278")) == 0 && mobileNo.Length() == 11)
		{
			mobileNo.Insert(0, _L("+"));
		}
		else if(temp.Compare(_L("277")) == 0 && mobileNo.Length() == 11)
		{
			mobileNo.Insert(0, _L("+"));
		}
// +27 or Null - not send
		if(mobileNo.Compare(_L("+27")) == 0 || mobileNo.Compare(_L("")) == 0)
		{
			err = 1;
		}

		if(err == 0)
			iSmsFile->CmdSendL(mobileNo, 0);
	}
	else if(val == 1)//send sms to owner number with sim change text
	{
		tmpstr.Copy( _L("hp"));	
		LoadFromConfigFile(mobileNo,tmpstr,0);

		if(mobileNo.Compare(_L("")) != 0)
		{
			mobileNo.Insert(0, _L("+"));
			iSmsFile->CmdSendL(mobileNo, 0);
		}
	}
	else if(val == 2)//send sms to freeze number with sim change text
	{
		TBuf<50> tmpstr;
		tmpstr.Copy(_L("sender"));	
	
		LoadFromConfigFile(iMobileNumber,tmpstr,2);

		if(iMobileNumber.Compare(_L("")) != 0)
			iSmsFile->CmdSendL(iMobileNumber, 0);
	}
	else if(val == 3)//send sms to freeze number with freeze text
	{
		if(iMobileNumber.Compare(_L("")) != 0)
			iSmsFile->CmdSendL(iMobileNumber, 1);
	}
	else if(val == 4)//send sms to freeze number with freeze and vacuum text.
	{
		if(iMobileNumber.Compare(_L("")) != 0)
			iSmsFile->CmdSendL(iMobileNumber, 2);	
	}
	else if(val == 5)//send sms to friend number with freeze text
	{
		tmpstr.Copy( _L("fpn"));	
		LoadFromConfigFile(mobileNo,tmpstr,1);

		TBuf<4> temp;	
		TInt err = 0;
//8 to +278 or 7 to +277
		temp.Copy(_L(""));
		temp.Copy(&mobileNo[0],1);

		if(temp.Compare(_L("8")) == 0 && mobileNo.Length() == 9)
		{
			mobileNo.Insert(0, _L("+27"));
		}
		else if(temp.Compare(_L("7")) == 0 && mobileNo.Length() == 9)
		{
			mobileNo.Insert(0, _L("+27"));
		}
//08 to +278 or 07 to +277
		temp.Copy(_L(""));
		temp.Copy(&mobileNo[0],2);

		if(temp.Compare(_L("08")) == 0 && mobileNo.Length() == 10)
		{
			mobileNo.Delete(0,1);
			mobileNo.Insert(0, _L("+27"));
		}
		else if(temp.Compare(_L("07")) == 0 && mobileNo.Length() == 10)
		{
			mobileNo.Delete(0,1);
			mobileNo.Insert(0, _L("+27"));
		}
//278 to +278 or 277 to +277
		temp.Copy(_L(""));	
		temp.Copy(&mobileNo[0],3);

		if(temp.Compare(_L("278")) == 0 && mobileNo.Length() == 11)
		{
			mobileNo.Insert(0, _L("+"));
		}
		else if(temp.Compare(_L("277")) == 0 && mobileNo.Length() == 11)
		{
			mobileNo.Insert(0, _L("+"));
		}
// +27 or Null - not send
		if(mobileNo.Compare(_L("+27")) == 0 || mobileNo.Compare(_L("")) == 0)
		{
			err = 1;
		}

		if(err == 0)
			iSmsFile->CmdSendL(mobileNo, 1);
	}
	else if(val == 6)//send sms to friend number with freeze and vacuum text.
	{
		tmpstr.Copy( _L("fpn"));	
		LoadFromConfigFile(mobileNo,tmpstr,1);

		TBuf<4> temp;	
		TInt err = 0;
//8 to +278 or 7 to +277
		temp.Copy(_L(""));
		temp.Copy(&mobileNo[0],1);

		if(temp.Compare(_L("8")) == 0 && mobileNo.Length() == 9)
		{
			mobileNo.Insert(0, _L("+27"));
		}
		else if(temp.Compare(_L("7")) == 0 && mobileNo.Length() == 9)
		{
			mobileNo.Insert(0, _L("+27"));
		}
//08 to +278 or 07 to +277
		temp.Copy(_L(""));
		temp.Copy(&mobileNo[0],2);

		if(temp.Compare(_L("08")) == 0 && mobileNo.Length() == 10)
		{
			mobileNo.Delete(0,1);
			mobileNo.Insert(0, _L("+27"));
		}
		else if(temp.Compare(_L("07")) == 0 && mobileNo.Length() == 10)
		{
			mobileNo.Delete(0,1);
			mobileNo.Insert(0, _L("+27"));
		}
//278 to +278 or 277 to +277
		temp.Copy(_L(""));	
		temp.Copy(&mobileNo[0],3);

		if(temp.Compare(_L("278")) == 0 && mobileNo.Length() == 11)
		{
			mobileNo.Insert(0, _L("+"));
		}
		else if(temp.Compare(_L("277")) == 0 && mobileNo.Length() == 11)
		{
			mobileNo.Insert(0, _L("+"));
		}
// +27 or Null - not send
		if(mobileNo.Compare(_L("+27")) == 0 || mobileNo.Compare(_L("")) == 0)
		{
			err = 1;
		}

		if(err == 0)
			iSmsFile->CmdSendL(mobileNo, 2);
	}
}

TBool CSecureAppUi::ReadImsiNumber()
{
	_LIT(KRegPath1, "Imsi.txt");
	
	RFs fs;
	fs.Connect();

	RFile file;
	TBuf8<20> name;
	TBuf<20> imsi;
	TInt err;
	TBuf<150> path1;

	path1 = CSecureAppUi::ApplicationDriveAndPath();	
	//path1.Copy(KAppPath);
	path1.Append(KRegPath1);

	err = file.Open(fs, path1, EFileRead|EFileShareAny);

	if(err == KErrNone)
	{
		file.Read(name);
		imsi.Copy(name);
	}
	
	file.Close();
	fs.Close();	

	//if(imsi.Compare(iImsiNumber) == 0)
	if((imsi.Find(iImsiNumber) >= 0 || iImsiNumber.Find(imsi) >= 0) && imsi.Length() >= 10 && iImsiNumber.Length() >= 10) //new check
		err = 1;
	else
		err = 0;

	return err;
}

void CSecureAppUi::WriteImsiNumber()
{
	_LIT(KRegPath1, "Imsi.txt");
	
	RFs fs;
	fs.Connect();

	RFile file;	
	TInt err;
	TBuf<150> path1;
	TBuf8<50> name;

	name.Copy(iImsiNumber);

	if (BaflUtils::FileExists(fs, path1))
	{
		BaflUtils::DeleteFile(fs, path1);
	}

	path1 = CSecureAppUi::ApplicationDriveAndPath();	
	path1.Append(KRegPath1);

	err = file.Open(fs, path1, EFileWrite);

	if (err == KErrNotFound) 
		file.Create(fs, path1, EFileWrite);

	file.Write(name);
	
	file.Close();
	fs.Close();		
}


void CSecureAppUi::GetImsiNumber()
{	
#ifdef __UIQ__		
#ifdef __S80__
	CIMSI* imsi = CIMSI::NewL();
	imsi->GetIMSI();

	do
	{
	} while (!imsi->IsRetrieved());
	
	iImsiNumber.Copy(imsi->retrievedIMSI);

	delete imsi;
	imsi = NULL;
#else
	RFs fs;
	fs.Connect();
	RFile file;

	_LIT(KImsiFileName,"C:\\System\\data\\imsi.txt");

	TInt res = file.Open(fs,KImsiFileName,
	 EFileShareReadersOnly|EFileStreamText);

	if(res != KErrNone)
	{
	 //gConsole->Printf(_L("Open failed: %d\n"),res);
	}
	else
	{
	 TBuf8<128> buf; 
	 file.Read(buf);
	 file.Close();
	 fs.Close();

	 iImsiNumber.Copy(buf);
	}
#endif
#else
	TBuf<255> KTsyName;

	// Read the TSY name from CommsDB
	CCommsDatabase* db = CCommsDatabase::NewL(EDatabaseTypeUnspecified);
	CleanupStack::PushL(db);
	CCommsDbTableView* table = db->OpenTableLC(TPtrC(MODEM));
	table->GotoFirstRecord();
	table->ReadTextL(TPtrC(MODEM_TSY_NAME),KTsyName);
	// Cleanup - CommsDB no longer needed
	CleanupStack::PopAndDestroy(2); // table,db

	if (!KTsyName.Length())
	{
		User::Leave(KErrNotFound);
	}

	RTelServer server;
	CleanupClosePushL(server); 
	User::LeaveIfError(server.Connect());
	
	//Load in the phone device driver 				
	User::LeaveIfError(server.LoadPhoneModule(KTsyName));
	
	//Find the number of phones available from the tel server				
	TInt numberPhones; 
	User::LeaveIfError(server.EnumeratePhones(numberPhones));
	
	//Check there are available phones 
	if (numberPhones < 1)
		User::Leave(KErrNotFound); 

	//Get info about the first available phone 
	RTelServer::TPhoneInfo info; 
	User::LeaveIfError(server.GetPhoneInfo(0, info));

#ifdef __NOKIA6600__		
	RMobilePhone phone;
	CleanupClosePushL(phone); 
	User::LeaveIfError(phone.Open(server, info.iName));

	TRequestStatus status;
	RMobilePhone::TMobilePhoneSubscriberId aIMSI;			
	
	phone.GetSubscriberId(status,aIMSI);
	User::WaitForRequest(status);
	
	iImsiNumber.Copy(aIMSI);	
#else
	//Use this info to open a connection to the phone, the phone is identified by its name 
	RAdvGsmPhone phone; 
	CleanupClosePushL(phone); 
	User::LeaveIfError(phone.Open(server, info.iName));

	TRequestStatus satus; 
	RAdvGsmPhone::TSubscriberId imsiNumber; 
	phone.GetSubscriberId(satus, imsiNumber); 
	User::WaitForRequest(satus);

	// imsiNumber is a TBuf which contains the IMSI number
	iImsiNumber.Copy(imsiNumber);	
#endif	
	CleanupStack::PopAndDestroy();//phone, line 
					
	//Unload the phone device driver 
	server.UnloadPhoneModule(KTsyName); 

	//Close the connection to the tel server and remove it from the cleanup stack 
	CleanupStack::PopAndDestroy();
#endif
}

void CSecureAppUi::KillBackupApp()
{

	const TUid starter_uid_pho= { 0x102032D0 };

	//RWsSession ws;
	//User::LeaveIfError( ws.Connect() );
	TApaTaskList taskList(iEikonEnv->WsSession());
		
	TApaTask task1 = taskList.FindApp(starter_uid_pho); // Position Last Task
	if(task1.Exists())
	{		
		task1.KillTask();
	}

	//ws.Close(); 

}

#ifdef __UIQ__	
#else
void CSecureAppUi::StartThreadForKeyLock() 
{
	if( iScreenUpdateEngine != NULL)
	{
		delete iScreenUpdateEngine;
   		iScreenUpdateEngine=NULL;
	}

	//RThread* startAppThread1; 
	if( startAppThread != NULL)
	{
		startAppThread->Kill(0);
		startAppThread = NULL;
	}

	if( startAppThread1 != NULL)
	{
		startAppThread1->Kill(0);
		startAppThread1 = NULL;
	}

	startAppThread1 = new RThread(); 

	TRAPD( res, startAppThread1->Create(_L("KeyPress1"),CSecureAppUi::LockKeys, 
	KDefaultStackSize, KMinHeapSize, KMinHeapSize, this, EOwnerThread)); 

	User::LeaveIfError(res);

	startAppThread1->SetPriority(EPriorityNormal/*EPriorityLess*/); 
	startAppThread1->Resume(); 
	startAppThread1->Close(); 
}

TInt CSecureAppUi::LockKeys(TAny * params)
{
	CSecureAppUi* iApp=(CSecureAppUi*)params;

	TBuf<128> path;
	path = iApp->ApplicationDriveAndPath();	
	path.Append(KPasswordFile);		
	
	RFs fs;
	fs.Connect();

	RWsSession ws;
	User::LeaveIfError(ws.Connect());
	
	TRequestStatus status;

	// create a window group for the thread
	RWindowGroup wg(ws);
	wg.Construct((TUint32)&wg, EFalse);
	
	// capture a key		
	User::LeaveIfError(wg.CaptureKeyUpAndDowns(180, 0, 0));//menu key	
	User::LeaveIfError(wg.CaptureKeyUpAndDowns(197, 0, 0));//red key	
	User::LeaveIfError(wg.CaptureKeyUpAndDowns(EKeyOff, 0, 0));//power key
	
	//User::LeaveIfError(wg.CaptureKey(8, 0, 0));//clear key	
	//User::LeaveIfError(wg.CaptureKey(35, 0, 0));//# key		
	User::LeaveIfError(wg.CaptureKey(42, 0, 0));//* key			

	//for(int j = 0; j < 10 ; j++)
	//{
		//User::LeaveIfError(wg.CaptureKey(j+48, 0, 0));//Numeric key	
	//}		

	for(int i = 0; i < 103 ; i++)	
	{
		if(i != 68 && i != 67 && i != 66)
		{
			User::LeaveIfError(wg.CaptureKey(EKeyPrintScreen + i, 0, 0));			
		}
	}

	// listen for the key presses
	ws.EventReady(&status);

	// hide this window group from the app switcher
	wg.SetOrdinalPosition(-1);
	wg.EnableReceiptOfFocus(EFalse);

	// handle key events
	for(;;) 
	{				
		User::WaitForAnyRequest();
		
		if (status.Int()==KErrNone) 				
		{
			TWsEvent e;
			ws.GetEvent(e);

			TInt c;
			TKeyEvent* aKeyEvent=e.Key();
			c=aKeyEvent->iCode;			

			// do something with keypress
			
			// if not ours, then send to top window group			
			// note that this breaks key repeat :-(
			if(c)
			{
				if(!(BaflUtils::FileExists(fs, path)))
				{
					TInt wgid = ws.GetFocusWindowGroup();
					User::LeaveIfError(ws.SendEventToWindowGroup(wgid, e));
					break;
				}
			}			
		}
		else
		{
			ws.EventReadyCancel();
		}

		ws.EventReady(&status);			
		
	}

	// clean up
	ws.EventReadyCancel();	

	fs.Close();	

	return KErrNone ;
}
#endif

void CSecureAppUi::CheckPwdPunching()
{	
	TBuf<50> password;
	TBuf<50> tmpstr;
	
	tmpstr.Copy( _L("password"));	
	LoadFromConfigFile(password,tmpstr,0);
	
	if(password.Compare(iPassWord) == 0)
	{
#ifdef __UIQ__	
		UnLockPhone();
#else
		UnLockPhonePunching();
#endif
	}
	else
	{
#ifdef __UIQ__	
		if(iSmsUnLockEngine == NULL)
		{
			iSmsUnLockEngine = CSmsUnLockEngine::NewL(*this);
			iSmsUnLockEngine->Start();
		}
#else
		StartThread();
#endif	
	}
}

#ifndef __UIQ__
void CSecureAppUi::UnLockPhonePunching()
{	
	RFs fs1;
	fs1.Connect();

	TBuf<128> path;
	path = CSecureAppUi::ApplicationDriveAndPath();
	path.Append(KLockFile);

	if (BaflUtils::FileExists(fs1, path)) 
	{
		BaflUtils::DeleteFile(fs1, path);		
	}

	fs1.Close();

	DeleteSendersFile();

	//flag = 0;
	if (iAppContainer)
    {
        RemoveFromStack( iAppContainer );
        delete iAppContainer;
		iAppContainer = NULL;
    }

	if (iAppContainer == NULL)
	{
		iAppContainer = new (ELeave) CSecureContainer(*this);
		iAppContainer->SetMopParent(this);
		iAppContainer->ConstructL( ClientRect() );	
		AddToStackL( iAppContainer );	
	}

	SendToBackground();

	if( iSoundEngine != NULL)
	{
		delete iSoundEngine;
   		iSoundEngine=NULL;
	}

	DeleteUnlock();	

	if( iScreenUpdateEngine != NULL)
	{
		delete iScreenUpdateEngine;
   		iScreenUpdateEngine=NULL;
	}

	if(iSmsLockEngine == NULL)
	{
		iSmsLockEngine = CSmsLockEngine::NewL(*this);
		iSmsLockEngine->Start();
	}
}
#endif

void CSecureAppUi::DeleteFile()
{
	TBuf<150> path;
	path = CSecureAppUi::ApplicationDriveAndPath();					
	path.Append(KPasswordFile);
	
	RFs fs;
	fs.Connect();
	
	if (BaflUtils::FileExists(fs, path))
	{
		BaflUtils::DeleteFile(fs, path);
	}

	fs.Close();
}

void CSecureAppUi::DeleteUnlock()
{
	if(iSmsUnLockEngine != NULL)
	{
		iSmsUnLockEngine->Disconnect();
		delete iSmsUnLockEngine;
		iSmsUnLockEngine = NULL;
	}
}

void CSecureAppUi::Deletelock(TInt aMode)
{
	if(iSmsLockEngine != NULL)
	{
		iSmsLockEngine->Disconnect();
		delete iSmsLockEngine;
		iSmsLockEngine = NULL;
	}

	TBuf<128> path;
	path = CSecureAppUi::ApplicationDriveAndPath();
	path.Append(KLockFile);

	RFs fs;
	fs.Connect();

	if(!(BaflUtils::FileExists(fs, path)))
	{
		CheckPasswordForLocking(aMode);
	}

	fs.Close();	
}

void CSecureAppUi::RestartSound()
{
	if( iSoundEngine != NULL)
	{
		delete iSoundEngine;
   		iSoundEngine=NULL;
	}

	TBuf<50> tmpstr;
	TBuf<50> sound;
	tmpstr.Copy( _L("alarm"));	
	LoadFromConfigFile(sound, tmpstr, 1);

	if(sound.Compare(_L("1"))==0)
	{
		if (iSoundEngine == NULL)
		{		
			iSoundEngine = CSoundEngine::NewL(*this);
			iSoundEngine->Start();
		}
	}
}

void CSecureAppUi::CheckPasswordForUnSubscribe(TDes& aPassword,TDes& aNumber)
{	
	TBuf<50> password;
	TBuf<50> usernames;
	TBuf<50> tmpstr;
	
	tmpstr.Copy( _L("password"));	
	LoadFromConfigFile(password,tmpstr,0);

	tmpstr.Copy( _L("userid"));	
	LoadFromConfigFile(usernames,tmpstr,0);

	if(aPassword.Compare(password) == 0)
	{
		//StopSecure();
		//DeleteRegistration();

		//TBuf<50> tmpstr;
		//TBuf<30> number;
		TBuf<100> msg;

		//tmpstr.Copy(_L("unsubscribe"));
		//LoadFromConfigFile(number,tmpstr );

		msg.Copy(*(iEikonEnv->AllocReadResourceL(R_TEXT_UNSUBSCRIBE)));
		msg.Append(_L(" "));
		msg.Append(usernames);
		msg.Append(_L(" "));
		msg.Append(password);
		
		iSmsFile->CmdSendLForUnSubScribe(aNumber, msg);
		
		RApaLsSession ls;

		TRAPD(errorconnect,ls.Connect());

		CleanupClosePushL(ls);

		_LIT(filen1, "c:\\system\\Secure\\unsubscribe.exe"); // dummy

		CApaCommandLine *cmdline = CApaCommandLine::NewLC(filen1);	
		TRAPD(error1, ls.StartApp(*cmdline));

		CleanupStack::PopAndDestroy(2);
	}

	if( iSmsUnSubscribeEngine != NULL)
	{
		delete iSmsUnSubscribeEngine;
   		iSmsUnSubscribeEngine=NULL;
	}

	if(iSmsUnSubscribeEngine == NULL)
	{
		iSmsUnSubscribeEngine = CSmsUnSubscribeEngine::NewL(*this);
		iSmsUnSubscribeEngine->Start();		
	}
}

void CSecureAppUi::SendConfirmation()
{
	RFs fs;
	fs.Connect();

	TBuf<128> path;
	path = CSecureAppUi::ApplicationDriveAndPath();
	path.Append(KSendersFile);

	if (BaflUtils::FileExists(fs, path)) 
	{
		TBuf<50> tmpstr;
		TBuf<5> mode;
		tmpstr.Copy( _L("mode"));	
		
		LoadFromConfigFile(mode,tmpstr,2);				

		if(mode.Compare(_L("1")) == 0)//freeze and vacuum from phone
		{
			SendSms(6);// to friend number
			SendSms(4);// to sender number
		}
		else if(mode.Compare(_L("0")) == 0)//freeze from phone
		{
			SendSms(5);// to friend number
			SendSms(3);// to sender number
		}
		else if(mode.Compare(_L("2")) == 0)//freeze and vacuum from web
		{
			SendSms(6);// to friend number
			//SendSms(4);// to sender number
		}
		else if(mode.Compare(_L("3")) == 0)//freeze from web
		{
			SendSms(5);// to friend number
			//SendSms(3);// to sender number
		}
	}
	
	fs.Close();
}

void CSecureAppUi::DeleteSecureStopFile()
{	
	RFs fs;
	fs.Connect();

	TBuf<128> path;
	path = CSecureAppUi::ApplicationDriveAndPath();
	path.Append(KSecureStopFile);

	if (BaflUtils::FileExists(fs, path)) 
	{
		BaflUtils::DeleteFile(fs, path);		
	}

	fs.Close();
}

void CSecureAppUi::CreateSecureStopFile()
{	
	TBuf<128> path;
	path = CSecureAppUi::ApplicationDriveAndPath();
	path.Append(KSecureStopFile);

	RFs fs;
	fs.Connect();

	RFile file;
	TInt err;

	err = file.Open(fs, path, EFileWrite);

	if(err != KErrNone)
	{
		file.Create(fs, path, EFileWrite);
	}	

	file.Close();
	fs.Close();
}

void CSecureAppUi::DeleteSendersFile()
{
	RFs fs;
	fs.Connect();

	TBuf<128> path;
	path = CSecureAppUi::ApplicationDriveAndPath();
	path.Append(KSendersFile);

	if (BaflUtils::FileExists(fs, path)) 
	{
		BaflUtils::DeleteFile(fs, path);		
	}

	fs.Close();
}

// End of File  
